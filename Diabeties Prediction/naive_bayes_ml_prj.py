# -*- coding: utf-8 -*-
"""Naive-Bayes-ML-Prj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BBiUwlp3AfxplZX6yIbDZZQygQJTICxH
"""

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

class NaiveBayes:
    def __init__(self):
        self.prior = None
        self.mean = None
        self.variance = None
        
    def fit(self, X, y):
        n_samples, n_features = X.shape
        
        self.prior = {}
        self.mean = {}
        self.variance = {}
        
        for c in np.unique(y):
            X_c = X[c == y]
            self.prior[c] = X_c.shape[0] / n_samples
            self.mean[c] = np.mean(X_c, axis=0)
            self.variance[c] = np.var(X_c, axis=0)
        
    def predict(self, X):
        y_pred = []
        for x in X:
            posterior = {}
            for c in self.prior:
                prior = np.log(self.prior[c])
                class_conditional = np.sum(np.log(self.normal_pdf(x, self.mean[c], self.variance[c])))
                posterior[c] = prior + class_conditional
            y_pred.append(max(posterior, key=posterior.get))
        return np.array(y_pred)
    
    def normal_pdf(self, x, mean, var):
        return 1 / np.sqrt(2 * np.pi * var) * np.exp(-(x - mean)**2 / (2 * var))

# load diabetes dataset
diabetes_data = np.loadtxt("diabetes.csv", delimiter=",", skiprows=1)

# split data into features and target variable
X = diabetes_data[:, :-1]
y = diabetes_data[:, -1]

# split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# standardize the data
X_train_mean = np.mean(X_train, axis=0)
X_train_std = np.std(X_train, axis=0)
X_train = (X_train - X_train_mean) / X_train_std
X_test = (X_test - X_train_mean) / X_train_std

# train the Naive Bayes model
nb = NaiveBayes()
nb.fit(X_train, y_train)

# make predictions on the testing set
y_pred = nb.predict(X_test)

# calculate accuracy of the model
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# count the number of 0's and 1's in the last column
count_0 = np.count_nonzero(diabetes_data[:, -1] == 0)
count_1 = np.count_nonzero(diabetes_data[:, -1] == 1)

print("Total Number of Non-Diabetic Persons:", count_0)
print("Total Number of Diabetic Persons:", count_1)

# predict whether a new input corresponds to a diabetic or non-diabetic person
new_input = np.array([2,197,70,45,543,30.5,0.158,53])
new_input_norm = (new_input - X_train_mean) / X_train_std
prediction = nb.predict(np.array([new_input_norm]))
if prediction[0] == 0:
    print("The person is non-diabetic")
else:
    print("The person is diabetic")

